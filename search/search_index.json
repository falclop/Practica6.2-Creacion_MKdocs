{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenido al Repositorio de Pr\u00e1cticas IaC de Fabi\u00e1n Alcaide","text":"<p>Este sitio contiene un conjunto de pr\u00e1cticas relacionadas con Infraestructura como C\u00f3digo (IaC), automatizaci\u00f3n, contenedores y administraci\u00f3n de servidores para la asignatura de IAW.  </p> <p>Adem\u00e1s esta p\u00e1gina ha sido realizada con GitPages</p>"},{"location":"#contenido","title":"Contenido","text":"<p>Aqu\u00ed encontrar\u00e1s enlaces directos a los repositorios de las pr\u00e1cticas disponibles:</p> <ul> <li>Practica 1.7 - WordPress con WP-CLI</li> <li>Practica 1.11 - Infraestructura 3 niveles con Bash</li> <li>Practica 3.2 - IaaC con Ansible</li> <li>Practica 4.5 - Terraform</li> <li>Practica 5.2 - WordPress Dockerizado</li> <li>Practica 5.4 - Dockerizar Imagen</li> <li>Practica 8.1 - Hosting Compartido PLESK</li> </ul>"},{"location":"#como-utilizar-este-sitio","title":"\u00bfC\u00f3mo utilizar este sitio?","text":"<p>Navega a trav\u00e9s del men\u00fa de la izquierda para acceder a cada una de las pr\u00e1cticas. Puedes hacer clic en los enlaces anteriores para dirigirte directamente a los repositorios en GitHub.</p> <p>Este sitio se actualiza autom\u00e1ticamente con nuevas pr\u00e1cticas y mejoras. \u00a1Explora y aprende!</p>"},{"location":"p111/","title":"Practica-11","text":"<p>Creaci\u00f3n de infraestructura entera de tres niveles con NFS  </p>"},{"location":"p111/#desarrollo-de-la-practica","title":"Desarrollo de la pr\u00e1ctica","text":"<p>En la siguiente pr\u00e1ctica vamos a desarrollar una arquitectura en tres niveles de despliegue de aplicaciones web, en ella vamos a contar con:  Un balanceador de carga con nginx* * Dos m\u00e1quinas front-end con apache 2.4 * Una m\u00e1quina back-end con mysql * Una m\u00e1quina servidor NFS que hace de almacenaje compartido para las m\u00e1quinas front-end  </p> <p>La estructura que vamos a crear va a seguir el siguiente diagrama  </p> <p> </p> <p>Para ello seguiremos el despliegue siguiendo los pasos de la pr\u00e1ctica anterior pero implementando una m\u00e1quina con NFS compartido.</p>"},{"location":"p111/#despliegue-de-la-practica","title":"Despliegue de la pr\u00e1ctica","text":"<p>Como hemos comentado, toda la pr\u00e1ctica se va a basar en despliegue anterior que podemos ver en el siguiente enlace A la cual le a\u00f1adiremos el despliegue de una nueva m\u00e1quina, a la que llamaremos server-nfs.  </p> <p>Esta m\u00e1quina la desplegaremos con el siguiente script <pre><code>#Actualizar el repositorio\napt update\n</code></pre> <pre><code>#Actualiza el paquete\napt upgrade -y\n</code></pre> <pre><code>#Instalamos los paquetes del servidor nfs\nsudo apt install nfs-kernel-server -y\n</code></pre> <pre><code>#Creamos el directorio a compartir, en este caso html en /var/www\nmkdir -p /var/www/html\n</code></pre> <pre><code>#Eliminamos tanto el propietario como el grupo al que pertenece el directorio\nchown nobody:nogroup /var/www/html\n</code></pre> Antes de seguir, debemos aclarar que debemos tener en nuestro repositorio el siguiente archivo exports. <pre><code>#Copiamos el archivo de las opciones de como se exportar\u00e1 el directorio\ncp ../nfs/exports /etc/exports\n</code></pre> <pre><code>#A\u00f1adimos a dicho archivo de configuraci\u00f3n las redes a las que har\u00e1 referencia\nsed -i \"s#FRONTEND_NETWORK#$FRONTEND_NETWORK#\" /etc/exports\n</code></pre> Despu\u00e9s de esta l\u00ednea veremos como el archivo se mantiene de esta forma. <pre><code>#Reiniciamos el servidor\nsystemctl restart nfs-kernel-server\n</code></pre></p> <p>Una vez hemos instalado el cliente, vamos a crear un script que vamos a lanzar en cada uno de las m\u00e1quinas y denominaremos setup_nfs_client</p> <p><pre><code>#Actualizar el repositorio\napt update\n</code></pre> <pre><code>#Actualiza el paquete\napt upgrade -y\n</code></pre> <pre><code>#Instalamos el cliente\nsudo apt install nfs-common -y\n</code></pre> <pre><code>#Montamos la carpeta en el directorio, con df -h podemos comprobarlo\nmount $NFS_SERVER_IP:/var/www/html /var/www/html\n</code></pre> <pre><code>#Creamos una copia de seguridad de fstab\ncp /etc/fstab /etc/fstab.bak\n</code></pre> <pre><code>#Creamos una entrada de acceso directo a fstab para garantizar que se monte al arranque de cada m\u00e1quina mount -a\nsed -i '/UEFI/a 172.31.84.55:/var/www/html /var/www/html nfs rsize=8192,wsize=8192,timeo=14,intr,noexec,nosuid' /etc/fstab\n</code></pre> </p> <p>Despu\u00e9s de lanzar nuestro script podemos ver como en las m\u00e1quinas de front-end el directorio /var/www/html esta montado sobre la m\u00e1quina nfs.  </p> <p> </p> <p>Para concluir vamos a decir el orden en el que debemos lanzar los scripts.  </p> <p>loadbalancer  - setup_loadbalancer - setup_letsencrypt</p> <p>frontend 1 y 2 - install_lamp_frontend - deploy_wordpress_frontend - setup_nfs_client</p> <p>backend - install_lamp_backend - deploy_wordpress_backend</p> <p>server nfs - setup_nfs_server</p>"},{"location":"p17/","title":"Practica-1.7","text":"<p>Automatizaci\u00f3n del Wordpress con WP-CLI</p>"},{"location":"p17/#desarrollo-de-la-practica","title":"Desarrollo de la pr\u00e1ctica","text":"<p>En esta pr\u00e1ctica vamos a seguir la misma hoja de ruta que la pr\u00e1ctica 1.6 pero con la diferencia del uso de WP-CLI, una aplicaci\u00f3n de wordpress, que nos ayuda a implementar nuestro sitio web de forma completamente aut\u00f3noma d\u00f3nde solo debemos establecer las variables de entorno para nombre del sitio, idioma o credenciales de administrador y el sitio ser\u00e1 desplegado de forma completamente aut\u00f3noma.  </p> <p>Junto a esto veremos tambi\u00e9n la automatizaci\u00f3n de la instalaci\u00f3n de temas y aplicaciones que nos ayudan a complementar nuestra m\u00e1quina como wp-hide-login, que oculta la p\u00e1gina de wp-login.php, desviando las miradas indiscretas de las partes cr\u00edticas de nuestro sistema.</p>"},{"location":"p17/#script-de-despliegue","title":"Script de despliegue","text":"<p>Debemos tener en cuenta el despliegue de estos script: * Preparamos el archivo .env con la plantilla .env.example * Registramos un dominio v\u00e1lido para nuestro sitio * Arrancamos install_lamp.sh * Arrancamos setup_letsencrypt_certificate</p> <p>Y preparamos nuestro script de deploy con las siguientes caracter\u00edsticas:  </p> <p>Eliminamos instalaciones anteriores <pre><code>rm -rf /opt/*\n</code></pre></p> <p>Descargamos el c\u00f3digo fuente de wp cli (man es manual / export para ver variables de entorno de la sesi\u00f3n) <pre><code>wget https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar -P /tmp\n</code></pre> Damos permisos de ejecuci\u00f3n al archivo</p> <p><pre><code>chmod +x /tmp/wp-cli.phar\n</code></pre> Movemos el script a usr/local/bin/ <pre><code>mv /tmp/wp-cli.phar /usr/local/bin/wp\n</code></pre> Eliminamos instalaciones anteriores <pre><code>rm -rf /var/www/html/*\n</code></pre> Instalamos worpress con el cli y las opciones wp core <pre><code>wp core download --locale=es_ES --path=$WP_PATH --allow-root\n</code></pre> Creamos la base de datos de wordpress <pre><code>mysql -u root &lt;&lt;&lt; \"DROP DATABASE IF EXISTS $WORDPRESS_DB_NAME\"\nmysql -u root &lt;&lt;&lt; \"CREATE DATABASE $WORDPRESS_DB_NAME\"\nmysql -u root &lt;&lt;&lt; \"DROP USER IF EXISTS $WORDPRESS_DB_USER@$IP_CLIENTE_MYSQL\"\nmysql -u root &lt;&lt;&lt; \"CREATE USER $WORDPRESS_DB_USER@$IP_CLIENTE_MYSQL IDENTIFIED BY '$WORDPRESS_DB_PASSWORD'\"\nmysql -u root &lt;&lt;&lt; \"GRANT ALL PRIVILEGES ON $WORDPRESS_DB_NAME.* TO $WORDPRESS_DB_USER@$IP_CLIENTE_MYSQL\"\n</code></pre> Creamos el archivo de configuraci\u00f3n <pre><code>wp config create \\\n  --dbname=$WORDPRESS_DB_NAME \\\n  --dbuser=$WORDPRESS_DB_USER \\\n  --dbpass=$WORDPRESS_DB_PASSWORD \\\n  --dbhost=$IP_CLIENTE_MYSQL \\\n  --path=$WP_PATH \\\n  --allow-root\n</code></pre> Creamos el sitio de wordpress <pre><code>wp core install \\\n  --url=$URL \\\n  --title=\"$WP_TITLE\" \\\n  --admin_user=$WP_USER \\\n  --admin_password=$WP_PASS \\\n  --admin_email=$WP_EMAIL \\\n  --path=$WP_PATH \\\n  --allow-root\n</code></pre> Cambiamos a todo los permisos de www-data <pre><code>chown -R www-data:www-data /var/www/html\n</code></pre> Activamos la rescritura de los permalinks o enlaces permanentes  <pre><code>wp rewrite structure '/%postname%/' \\\n  --path=$WP_PATH \\\n  --allow-root\n</code></pre> Copiamos nuestro archivo .htaccess para activar los permalinks <pre><code>cp ../htaccess/.htaccess $WP_PATH\n</code></pre> Instalamos y activamos el theme elegido <pre><code>wp theme install mindscape --activate --path=$WP_PATH --allow-root\n</code></pre> Instalamos el plugin para ocultar nuestro archivo wp-admin <pre><code>wp plugin install wps-hide-login --activate --path=$WP_PATH --allow-root\n</code></pre> Configuramos el plugin ocultador de wp-login <pre><code>wp option update whl_page $nombre_secreto --path=$WP_PATH --allow-root\n</code></pre> Desactivamos un plugin, esto es un extra. Para saber como desactivar un plugin <pre><code># wp plugin deactivate wps-hide-login\n</code></pre> Cambiamos a todo los permisos de www-data <pre><code>chown -R www-data:www-data /var/www/html\n</code></pre></p>"},{"location":"p17/#comprobaciones","title":"Comprobaciones","text":"<p>Una vez lanzado nuestro script, instalado nuestro archivo fuente de wordpress y lanzadas las opciones del cli, solo tendremos que entrar en nuestro dominio para ver las siguientes opciones:  </p> <p>Al entrar la primera vez, vemos que ya est\u00e1 todo configurado </p> <p>Comprobamos que el ocultamiento de wp-login funciona </p> <p> </p> <p>Comprobamos los permalinks </p> <p> </p> <p>Entrada hola mundo!  </p>"},{"location":"p32/","title":"Practica-3.2-IAW","text":""},{"location":"p32/#despliegue-de-wordpress-en-tres-niveles-mediante-ansible","title":"Despliegue de Wordpress en tres niveles mediante Ansible","text":"<p>En esta pr\u00e1ctica vamos a realizar un despliegue de un sitio de moodle siguiendo la misma pauta de la pr\u00e1ctica 11, una infraestructura a tres niveles (balanceador de carga, frontend y backend) en m\u00e1quinas diferentes siguiendo el siguiente esquema. </p> <p>En este esquema, el balanceador de carga tendr\u00e1 un certificado Let's Encrypt, las m\u00e1quinas de frontend tienen el directorio /var/www/html de apache2, compartido por una m\u00e1quina nfs_server y al final una m\u00e1quina backend (no dos como en la imagen) con el servicio de MySQL.  </p>"},{"location":"p32/#explicacion-del-repositorio","title":"Explicaci\u00f3n del repositorio","text":"<p>Este repositorio tiene todo lo necesario para el lanzamiento de este sitio CMS (Content Manager System), en este caso WordPress. La estructura global de nuestro repo ser\u00e1 la siguiente:  </p> <p> </p> <ul> <li>El inventory, ser\u00e1 el archivo donde colocamos las diferentes ip de las m\u00e1quinas que pertenecen a nuestros grupos. </li> </ul> <p>Las \u00faltimas l\u00edneas se alude a las claves ssh que deben estar en la m\u00e1quina para el funcionamiento de Ansible.  </p> <ul> <li> <p>exports, el archivo que especifica el comportamiento del directorio a compartir (ir\u00e1 en la m\u00e1quina nfs_server). <pre><code>/var/www/html FRONTEND_NETWORK(rw,sync,no_root_squash,no_subtree_check)\n</code></pre></p> </li> <li> <p>Los playbooks, ser\u00e1n los diferentes \"libros de jugadas\" donde se colocan l\u00e1s tareas que se ejecutan. Aqu\u00ed tendremos:</p> <ul> <li> <p>install_lamp_backend.yaml     Instalaci\u00f3n de los paquetes de LAMP de Backend: MySQL.  </p> </li> <li> <p>install_lamp_frontend.yaml </p> <p>Instalaci\u00f3n de los paquetes de LAMP de Frontend: Apache2 y PHP.</p> </li> <li> <p>setup_load_balancer.yaml </p> <p>Instalaci\u00f3n de las dependecias del balanceador de carga.  </p> </li> <li> <p>setup_nfs_server.yaml </p> <p>Instalaci\u00f3n de las dependencias del servidor NFS.</p> </li> <li> <p>setup_nfs_client.yaml </p> <p>Instalaci\u00f3n de las dependecias para montar el volumen /var/www/html en las m\u00e1quinas frontend.  </p> </li> <li> <p>setup_letsencrypt_certificate.yaml </p> <p>Instalaci\u00f3n y petici\u00f3n de certificado Let's Encrypt para la m\u00e1quina balanceador de carga.  </p> </li> <li> <p>deploy_wordpress_backend.yaml </p> <p>Instalaci\u00f3n de dependencias de backend de WP: bases de datos.  </p> </li> <li> <p>deploy_wordpress_frontend.yaml </p> <p>Instalaci\u00f3n de dependencias de frontend de WP: instalaci\u00f3n de CLI, plugins, y reescritura de permalinks.  </p> </li> </ul> </li> </ul>"},{"location":"p32/#instalacion-de-scripts","title":"Instalaci\u00f3n de scripts","text":"<p>El n\u00facleo fuerte del repositorio ser\u00e1 la instalaci\u00f3n de wordpress, para ello una vez tenemos la Pila LAMP instalada e instalamos el Let's Encrypt veremos como funciona el NFS Client y Server. - Servidor NFS <pre><code>---\n- name: Configurar servidor NFS\n  hosts: nfs_server\n  become: yes\n  vars_files:\n    - ../vars/variables.yaml\n\n  tasks:\n    - name: Actualizar el repositorio de paquetes\n      apt:\n        update_cache: yes\n\n    - name: Actualizar paquetes del sistema\n      apt:\n        upgrade: dist\n        autoremove: yes\n\n    - name: Instalar el servidor NFS\n      apt:\n        name: nfs-kernel-server\n        state: present\n\n    - name: Crear el directorio compartido\n      file:\n        path: /var/www/html\n        state: directory\n        owner: nobody\n        group: nogroup\n        mode: '0775'\n\n    - name: Copiar configuraci\u00f3n de exportaci\u00f3n NFS\n      copy:\n        src: ../nfs/exports\n        dest: /etc/exports\n        owner: root\n        group: root\n        mode: '0644'\n\n    - name: Configurar la red de exportaci\u00f3n en /etc/exports\n      replace:\n        path: /etc/exports\n        regexp: 'FRONTEND_NETWORK'\n        replace: \"{{ ip.net }}\"\n\n    - name: Reiniciar el servicio NFS\n      systemd:\n        name: nfs-kernel-server\n        state: restarted\n        enabled: yes\n</code></pre> - Clientes NFS <pre><code>---\n- name: Configurar cliente NFS en servidores frontend\n  hosts: frontend\n  become: yes\n  vars_files:\n    - ../vars/variables.yaml\n\n  tasks:\n    - name: Actualizar el repositorio de paquetes\n      apt:\n        update_cache: yes\n\n    - name: Actualizar paquetes del sistema\n      apt:\n        upgrade: dist\n        autoremove: yes\n\n    - name: Instalar el cliente NFS\n      apt:\n        name: nfs-common\n        state: present\n\n    - name: Crear el punto de montaje para NFS\n      file:\n        path: /var/www/html\n        state: directory\n        owner: www-data\n        group: www-data\n        mode: '0755'\n\n    - name: Montar el sistema de archivos NFS temporalmente\n      command: mount {{ ip.nfsserver }}:/var/www/html /var/www/html\n      args:\n        creates: /var/www/html/index.php  # Verifica que el montaje no se repita\n\n    - name: Crear copia de seguridad de /etc/fstab\n      copy:\n        src: /etc/fstab\n        dest: /etc/fstab.bak\n        remote_src: yes\n        mode: '0644'\n\n    - name: Agregar la configuraci\u00f3n de montaje de NFS a /etc/fstab\n      lineinfile:\n        path: /etc/fstab\n        insertafter: 'UEFI'\n        line: \"{{ ip.nfsserver }}:/var/www/html /var/www/html nfs rsize=8192,wsize=8192,timeo=14,intr,noexec,nosuid\"\n        state: present\n\n    - name: Montar todos los sistemas de archivos definidos en fstab\n      command: mount -a\n</code></pre> - Despliegue backend <pre><code>---\n- name: Despliegue de backend de wordpress\n  hosts: backend\n  become: yes\n  vars_files:\n    - ../vars/variables.yaml\n\n  tasks:\n    - name: Borrar la base de datos\n      mysql_db:\n        name: \"{{ db.name }}\"\n        state: absent\n        login_unix_socket: /var/run/mysqld/mysqld.sock\n\n    - name: Crear una base de datos\n      mysql_db:\n        name: \"{{ db.name }}\"\n        state: present\n        login_unix_socket: /var/run/mysqld/mysqld.sock \n\n    - name: Crear el usuario de la base de datos\n      mysql_user:         \n        name: \"{{ db.user }}\"\n        password: \"{{ db.pass }}\"\n        priv: \"{{ db.name }}.*:ALL\"\n        host: \"{{ ip.net }}\" #Aqu\u00ed usamos la red completa 172.31.0.0/16\n        state: present\n        login_unix_socket: /var/run/mysqld/mysqld.sock \n\n    - name: Configuramos MySQL para permitir conexiones desde cualquier interfaz\n      replace:\n        path: /etc/mysql/mysql.conf.d/mysqld.cnf\n        regexp: 127.0.0.1\n        replace: 0.0.0.0\n\n    - name: Reiniciamos el servicio de base de datos\n      service:\n        name: mysql\n        state: restarted\n</code></pre> - Despliegue frontend <pre><code>---\n- name: Deploy Moodle front\n  hosts: frontend_master\n  become: yes\n  vars_files:\n    - ../vars/variables.yaml\n\n  tasks:\n      - name: Eliminar instalaciones anteriores de wp-cli\n        file:\n          path: /tmp/wp-cli.phar\n          state: absent\n\n      - name: Descargar WP-CLI\n        get_url:\n          url: https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar\n          dest: /tmp/wp-cli.phar\n          mode: '0755'\n\n      - name: Mover wp-cli.phar a /usr/local/bin/wp\n        command: mv /tmp/wp-cli.phar /usr/local/bin/wp\n        args:\n          creates: /usr/local/bin/wp\n\n      - name: Eliminar contenido anterior de WordPress\n        # En esta l\u00ednea usamos shell en vez de file y state:absent ya que como necesitamos borrar el contenido \n        # y el directorio esta siendo usado por nfs, lo hacemos para evitar fallos\n        shell: rm -rf /var/www/html/*\n\n        # A partir de aqu\u00ed vamos a usar el comando command, ya que no exiten comandos nativos en ansible para usar el CLI de wordpress\n      - name: Descargar e instalar WordPress\n        command: wp core download --locale=es_ES --path={{ wp.path }} --allow-root\n\n      - name: Crear el archivo de configuraci\u00f3n de WordPress\n        command:\n          wp config create \\\n          --dbname={{ db.name }} \\ \n          --dbuser={{ db.user }} \\\n          --dbpass={{ db.pass }} \\\n          --dbhost={{ ip.back }} \\\n          --path={{ wp.path }} \\\n          --allow-root\n\n      - name: Instalar WordPress\n        command:\n          wp core install \\\n          --url=\"https://{{ cerbot.url }}\" \\\n          --title=\"{{ wp.title }}\" \\\n          --admin_user={{ wp.user }} \\ \n          --admin_password={{ wp.pass }} \\\n          --admin_email={{ wp.email }} \\\n          --path={{ wp.path }} \\\n          --allow-root\n\n      - name: Establecer permisos de WordPress\n        file:\n          path: /var/www/html\n          owner: www-data\n          group: www-data\n          recurse: yes\n\n      - name: Configurar enlaces permanentes de WordPress\n        command: wp rewrite structure '/%postname%/' --path={{ wp.path }} --allow-root\n\n      - name: Copiar archivo .htaccess para activar permalinks\n        copy:\n          src: ../templates/.htaccess\n          dest: \"{{ wp.path }}/.htaccess\"\n          owner: www-data\n          group: www-data\n          mode: '0644'\n\n      - name: Instalar y activar el tema Mindscape\n        command: wp theme install mindscape --activate --path={{ wp.path }} --allow-root\n\n      - name: Instalar y activar el plugin WPS Hide Login\n        command: wp plugin install wps-hide-login --activate --path={{ wp.path }} --allow-root\n\n      - name: Configurar la URL secreta de wp-admin\n        command: wp option update whl_page {{ wp.nombre_secreto }} --path={{ wp.path }} --allow-root\n\n      - name: Agregar configuraci\u00f3n HTTPS en wp-config.php\n        lineinfile:\n          path: /var/www/html/wp-config.php\n          line: \"$_SERVER['HTTPS'] = 'on';\"\n          insertafter: \"COLLATE\"\n\n      - name: Establecer permisos finales de WordPress\n        file:\n          path: /var/www/html\n          owner: www-data\n          group: www-data\n          recurse: yes\n</code></pre></p>"},{"location":"p32/#comprobaciones","title":"Comprobaciones","text":"<p>Una vez hemos lanzado todos los scripts y vemos como nos ha funcionado, veremos la siguiente pantalla. - Funcionamiento normal </p> <p> </p> <ul> <li>Reescritura de permalinks </li> </ul> <p> </p> <ul> <li>Plugin de ocultamiento de login </li> </ul> <p></p>"},{"location":"p45/","title":"Pr\u00e1ctica-4.5-Terraform","text":"<p>Despliegue de infraestructuras usando el software terraform</p>"},{"location":"p45/#desarrollo-de-la-actividad","title":"Desarrollo de la actividad","text":"<p>En la siguiente actividad vamos a usar el software terraform. Terraform es una software de c\u00f3digo abierto desarrollado por Hashicorp que se coloca como intermediario entre el servicio de cloud computing y el equipo desde donde se disparan las ordenes.  </p> <p>Este sistema se ha colocado como la principal herramienta para el IaaC (Infrastructure as a Code) y los profesionales del despliegue de infraestrutura por su versatilidad a la hora de crear c\u00f3digos para despliegues de m\u00e1quinas, y adem\u00e1s por su facil uni\u00f3n con otras herramientas como Ansible o boto3 en python.</p>"},{"location":"p45/#el-depliegue","title":"El depliegue","text":"<p>Para la actividad primero vamos a conocer como funciona terraform, primero debemos crear los archivos variables.tf, main.tf y output.tf (ya que siempre es buena praxis diferenciar los documentos, ya que cuanta menos superficie de ataque mejor), estos archivos sigue el formato json, de diccionario clave = valor.  </p> <p>main.tf <pre><code># Configuramos el proveedor de AWS\nprovider \"aws\" {\n  region = var.region\n}\n\n# Creamos los grupos de seguridad\nresource \"aws_security_group\" \"grupo_seguridad_lb\" {\n  name        = var.sg_name_loadbalancer\n  description = var.sg_description\n}\n\nresource \"aws_security_group\" \"grupo_seguridad_nfs\" {\n  name        = var.sg_name_nfs\n  description = var.sg_description\n}\n\nresource \"aws_security_group\" \"grupo_seguridad_frontend\" {\n  name        = var.sg_name_frontend\n  description = var.sg_description\n}\n\nresource \"aws_security_group\" \"grupo_seguridad_backend\" {\n  name        = var.sg_name_backend\n  description = var.sg_description\n}\n\n# Creamos las reglas de entrada del grupo de seguridad\nresource \"aws_security_group_rule\" \"ingress_load_balancer\" {\n  security_group_id = aws_security_group.grupo_seguridad_lb.id\n  type              = \"ingress\"\n  count             = length(var.allowed_ingress_ports_loadbalancer)\n  from_port         = var.allowed_ingress_ports_loadbalancer[count.index]\n  to_port           = var.allowed_ingress_ports_loadbalancer[count.index]\n  protocol          = \"tcp\"\n  cidr_blocks       = [\"0.0.0.0/0\"]\n}\n\nresource \"aws_security_group_rule\" \"ingress_nfs\" {\n  security_group_id = aws_security_group.grupo_seguridad_nfs.id\n  type              = \"ingress\"\n  count             = length(var.allowed_ingress_ports_nfs)\n  from_port         = var.allowed_ingress_ports_nfs[count.index]\n  to_port           = var.allowed_ingress_ports_nfs[count.index]\n  protocol          = \"tcp\"\n  cidr_blocks       = [\"0.0.0.0/0\"]\n}\n\nresource \"aws_security_group_rule\" \"ingress_frontend\" {\n  security_group_id = aws_security_group.grupo_seguridad_frontend.id\n  type              = \"ingress\"\n  count             = length(var.allowed_ingress_ports_frontend)\n  from_port         = var.allowed_ingress_ports_frontend[count.index]\n  to_port           = var.allowed_ingress_ports_frontend[count.index]\n  protocol          = \"tcp\"\n  cidr_blocks       = [\"0.0.0.0/0\"]\n}\n\nresource \"aws_security_group_rule\" \"ingress_backend\" {\n  security_group_id = aws_security_group.grupo_seguridad_backend.id\n  type              = \"ingress\"\n  count             = length(var.allowed_ingress_ports_backend)\n  from_port         = var.allowed_ingress_ports_backend[count.index]\n  to_port           = var.allowed_ingress_ports_backend[count.index]\n  protocol          = \"tcp\"\n  cidr_blocks       = [\"0.0.0.0/0\"]\n}\n\n# Creamos las reglas de salida del grupo de seguridad\n# Para ello usamos un bucle for_each para recorrer los grupos de seguridad\nresource \"aws_security_group_rule\" \"egress_all\" {\n  for_each         = {\n    lb = aws_security_group.grupo_seguridad_lb.id,\n    nfs = aws_security_group.grupo_seguridad_nfs.id,\n    frontend = aws_security_group.grupo_seguridad_frontend.id,\n    backend = aws_security_group.grupo_seguridad_backend.id\n  }\n  security_group_id = each.value\n  type              = \"egress\"\n  from_port         = 0\n  to_port           = 0\n  protocol          = \"-1\"\n  cidr_blocks       = [\"0.0.0.0/0\"]\n}\n\n# Creamos las instancias EC2\nresource \"aws_instance\" \"instancia_loadbalancer\" {\n  ami             = var.ami_id\n  instance_type   = var.instance_type\n  key_name        = var.key_name\n  security_groups = [aws_security_group.grupo_seguridad_lb.name]\n\n  tags = {\n    Name = var.instance_name_loadbalancer\n  }\n}\n\nresource \"aws_instance\" \"instancia_nfs\" {\n  ami             = var.ami_id\n  instance_type   = var.instance_type\n  key_name        = var.key_name\n  security_groups = [aws_security_group.grupo_seguridad_nfs.name]\n  tags = {\n    Name = var.instance_name_nfs\n  }\n}\n\nresource \"aws_instance\" \"instancia_frontend\" {\n  ami             = var.ami_id\n  instance_type   = var.instance_type\n  key_name        = var.key_name\n  security_groups = [aws_security_group.grupo_seguridad_frontend.name]\n  tags = {\n    Name = var.instance_name_frontend\n  }\n}\n\nresource \"aws_instance\" \"instancia_frontend2\" {\n  ami             = var.ami_id\n  instance_type   = var.instance_type\n  key_name        = var.key_name\n  security_groups = [aws_security_group.grupo_seguridad_frontend.name]\n  tags = {\n    Name = var.instance_name_frontend2\n  }\n}\n\nresource \"aws_instance\" \"instancia_backend\" {\n  ami             = var.ami_id\n  instance_type   = var.instance_type\n  key_name        = var.key_name\n  security_groups = [aws_security_group.grupo_seguridad_backend.name]\n  tags = {\n    Name = var.instance_name_backend\n  }\n}\n\n# Creamos una IP el\u00e1stica y la asociamos a la instancia\nresource \"aws_eip\" \"ip_elastica\" {\n  instance = aws_instance.instancia_loadbalancer.id\n}\n</code></pre></p> <p>variables.tf <pre><code>variable \"region\" {\n  description = \"Regi\u00f3n de AWS donde se crear\u00e1 la instancia\"\n  type        = string\n  default     = \"us-east-1\"\n}\n\nvariable \"allowed_ingress_ports_loadbalancer\" {\n  description = \"Puertos de entrada del grupo de seguridad loadbalancer\"\n  type        = list(number)\n  default     = [22, 80, 443]\n}\n\nvariable \"allowed_ingress_ports_nfs\" {\n  description = \"Puertos de entrada del grupo de seguridad nfs\"\n  type        = list(number)\n  default     = [22, 2049]\n}\n\nvariable \"allowed_ingress_ports_backend\" {\n  description = \"Puertos de entrada del grupo de seguridad backend\"\n  type        = list(number)\n  default     = [22, 3306]\n}\n\nvariable \"allowed_ingress_ports_frontend\" {\n  description = \"Puertos de entrada del grupo de seguridad frontend\"\n  type        = list(number)\n  default     = [22, 2049, 443, 80]\n}\n\nvariable \"sg_name_loadbalancer\" {\n  description = \"Nombre del grupo de seguridad\"\n  type        = string\n  default     = \"sg_loadbalancer\"\n}\n\nvariable \"sg_name_nfs\" {\n  description = \"Nombre del grupo de seguridad\"\n  type        = string\n  default     = \"sg_nfs\"\n}\n\nvariable \"sg_name_frontend\" {\n  description = \"Nombre del grupo de seguridad\"\n  type        = string\n  default     = \"sg_frontend\"\n}\n\nvariable \"sg_name_backend\" {\n  description = \"Nombre del grupo de seguridad\"\n  type        = string\n  default     = \"sg_backend\"\n}\n\nvariable \"sg_description\" {\n  description = \"Descripci\u00f3n del grupo de seguridad\"\n  type        = string\n  default     = \"Grupo de seguridad para ejercicio terraform\"\n}\n\nvariable \"ami_id\" {\n  description = \"Identificador de la AMI\"\n  type        = string\n  default     = \"ami-04b4f1a9cf54c11d0\"\n}\n\nvariable \"instance_type\" {\n  description = \"Tipo de instancia\"\n  type        = string\n  default     = \"t2.micro\"\n}\n\nvariable \"key_name\" {\n  description = \"Nombre de la clave p\u00fablica\"\n  type        = string\n  default     = \"vockey\"\n}\n\nvariable \"instance_name_backend\" {\n  description = \"Nombre de la instancia\"\n  type        = string\n  default     = \"instancia_backend\"\n}\n\nvariable \"instance_name_frontend\" {\n  description = \"Nombre de la instancia\"\n  type        = string\n  default     = \"instancia_frontend\"\n\n}\n\nvariable \"instance_name_frontend2\" {\n  description = \"Nombre de la instancia\"\n  type        = string\n  default     = \"instancia_frontend2\"\n\n}\n\nvariable \"instance_name_loadbalancer\" {\n  description = \"Nombre de la instancia\"\n  type        = string\n  default     = \"instancia_loadbalancer\"\n}\n\nvariable \"instance_name_nfs\" {\n  description = \"Nombre de la instancia\"\n  type        = string\n  default     = \"instancia_nfs\"\n}\n</code></pre></p> <p>output.tf <pre><code># Mostramos la IP p\u00fablica de la instancia\noutput \"elastic_ip\" {\n  value = aws_eip.ip_elastica.public_ip\n}\n\noutput \"public_ip_nfs\" {\n  value = aws_instance.instancia_nfs.public_ip\n}\n\noutput \"public_ip_frontend\" {\n  value = aws_instance.instancia_frontend.public_ip\n}\n\noutput \"public_ip_frontend2\" {\n  value = aws_instance.instancia_frontend2.public_ip\n}\n</code></pre></p> <p>Una vez tenemos los documentos, debemos conocer la secuencia de comandos: - terraform init: inicia el entorno de trabajo para terraform.  </p> <p> </p> <ul> <li> <p>terraform fmt: formatea el documento main para que cumpla la forma correcta.</p> </li> <li> <p>terraform plan: da una vista previa de los comandos y las actuaciones que se van a ejecutar.  </p> </li> </ul> <p> </p> <ul> <li>terraform apply: ejecuta las \u00f3rdenes del main.tf.  </li> </ul> <p> </p> <p>Como vemos nos pide una confirmaci\u00f3n, para evitarla podemos poner la opci\u00f3n -auto-approve </p> <p>Adem\u00e1s como podemos comprobar, la salida que nos muestra es las diferentes variables que programamos en output.tf </p>"},{"location":"p45/#comprobaciones","title":"Comprobaciones","text":"<p>Si vamos a nuestro laboratorio de AWS veremos las instancias, la ip el\u00e1stica y los grupos de seguridad, creados y asignados.  </p> <p> </p> <p> </p> <p></p>"},{"location":"p52/","title":"Practica5.2-IAW-WordPress-Dockerizado","text":"<p>Despliegue de WordPress con Docker y Docker Compose</p>"},{"location":"p52/#explicacion-de-la-practica","title":"Explicaci\u00f3n de la pr\u00e1ctica","text":"<p>Para la siguiente pr\u00e1ctica vamos a crear una estructura de back y front de wordpress, junto a una m\u00e1quina que realiza los retos de Let's Encrypt, todo ello mediante aplicaciones contenedorizados, siguiendo la siguiente estructura:  </p> <p> </p> <p>Para ello vamos a desarrollar un documento docker-compose.yml donde se especifican las m\u00e1quinas que se van a crear.  </p>"},{"location":"p52/#comandos-a-usar-con-docker-compose","title":"Comandos a usar con docker-compose","text":"<p>docker ps: Ver los contenedores activas.  </p> <p>docker compose up -d: Lanza las instrucciones que se encuentran en el docker-compose.yml.  </p> <p>docker compose down -v: Destruye todos los contenedores junto a volumenes, dependencias y redes.  </p> <p>docker logs: Muestra los logs del contenedor que pongamos.  </p> <p>docker images: Ver las im\u00e1genes que nos hemos descargados de contenedores.  </p> <p>docker system events: Ver los eventos del sistema en docker.  </p>"},{"location":"p52/#desarrollo-de-la-practica","title":"Desarrollo de la pr\u00e1ctica","text":"<p>Primero tendremos una instancia limpia para poder trabajar con las siguientes caracter\u00edsticas.  </p> <p></p> <p>Luego obtenemos una ip el\u00e1stica para nuestra instancia.  </p> <p></p> <p>Para ello vamos a tirar primero el script install_docker.sh, con ello aseguramos la descarga de docker-compose de \u00faltimo modelo.  </p> <p>Una vez tenemos el sistema preparado elaboramos la siguiente hoja: - Creaci\u00f3n de servicio mysql <pre><code>services:\n  mysql:\n    image: mysql\n    ports: \n      - 3306:3306\n    environment: \n      - MYSQL_ROOT_PASSWORD=${WORDPRESS_DATABASE_PASSWORD}\n      - MYSQL_DATABASE=${WORDPRESS_DATABASE_NAME}\n      - MYSQL_USER=${WORDPRESS_DATABASE_USER}\n      - MYSQL_PASSWORD=${WORDPRESS_DATABASE_PASSWORD}\n    volumes: \n      - mysql_data:/var/lib/mysql\n    networks: \n      - backend-network\n    restart: always\n</code></pre> - Creaci\u00f3n de servicio phpmyadmin <pre><code>  phpmyadmin:\n    image: phpmyadmin/phpmyadmin\n    ports:\n      - 8080:80\n    environment: \n      - PMA_HOST=mysql\n    networks: \n      - backend-network\n      - frontend-network\n    restart: always\n    depends_on: \n      - mysql\n</code></pre> - Creaci\u00f3n de servicio wordpress </p> <p><pre><code>  wordpress:\n    image: bitnami/wordpress\n    environment:\n      - WORDPRESS_DATABASE_HOST=${WORDPRESS_DATABASE_HOST}\n      - WORDPRESS_DATABASE_USER=${WORDPRESS_DATABASE_USER}\n      - WORDPRESS_DATABASE_PASSWORD=${WORDPRESS_PASSWORD}\n      - WORDPRESS_DATABASE_NAME=${WORDPRESS_DATABASE_NAME}\n      - WORDPRESS_BLOG_NAME=${WORDPRESS_BLOG_NAME}\n      - WORDPRESS_USERNAME=${WORDPRESS_USERNAME}\n      - WORDPRESS_PASSWORD=${WORDPRESS_PASSWORD}\n      - WORDPRESS_EMAIL=${WORDPRESS_EMAIL}\n    volumes:\n      - wordpress_data:/bitnami/wordpress\n    depends_on:\n      - mysql\n    restart: always\n    networks:\n      - frontend-network\n      - backend-network\n</code></pre> - Creaci\u00f3n de servicio https-portal </p> <pre><code>  https-portal:\n    image: steveltn/https-portal\n    ports:\n      - 80:80\n      - 443:443\n    restart: always\n    environment:\n      DOMAINS: \"${DOMAIN} -&gt; http://wordpress:8080\"\n      STAGE: 'production' # Don't use production until staging works\n      # FORCE_RENEW: 'true'\n    networks:\n      - frontend-network\n</code></pre> <pre><code>volumes:\n  mysql_data:\n  wordpress_data:\n\nnetworks: \n  backend-network:\n  frontend-network:\n</code></pre> <p>Una vez elaborado el documento, lo lanzamos y vemos que se crear tanto el volumen, las redes y los contenedores.  </p> <p> </p> <p>Y finalmente todo ir\u00e1 funcionando poco a poco, cuando los puertos est\u00e9n bien conformado, el port-forwarding funciona, accedemos a la url.  </p> <p> </p> <p>Y phpmyadmin.  </p> <p></p>"},{"location":"p52/#enlaces","title":"Enlaces","text":"<ul> <li> <p>Enlace del blog: https://practica5-2fabian.zapto.org/</p> </li> <li> <p>Enlace a phpmyadmin: https://practica5-2fabian.zapto.org:8080</p> </li> </ul>"},{"location":"p54/","title":"Practica5.4-IAW-Dockerizar-imagen","text":"<p>Creaci\u00f3n de imagen dockerizada de un servicio y subirlo a DockerHub.</p>"},{"location":"p54/#explicacion-de-la-practica","title":"Explicaci\u00f3n de la pr\u00e1ctica","text":"<p>En esta pr\u00e1ctica vamos a implementar la creaci\u00f3n de un docker con un web est\u00e1tica, el juego del 2048, usando la tecnolog\u00eda docker compose. Los pasos a seguir ser\u00e1n los siguientes: - Crear un Dockerfile. - Crear una imagen de docker con Docker Buildx. - Crear el docker-compose.yml para despliegue de imagen. - Despliegue de aplicaci\u00f3n y comprobaci\u00f3n. - Subir imagen a docker hub, podemos verla aqu\u00ed. - Creaci\u00f3n de GitHub Actions para implementar CI/CD.</p>"},{"location":"p54/#desarrollo-de-la-aplicacion","title":"Desarrollo de la aplicaci\u00f3n","text":"<ol> <li>Dockerfile Un Dockerfile es un archivo que contiene las instrucciones para la creaci\u00f3n de una imagen de docker. Esta se compone de varias partes, que pueden ser reutilizables y hacen que se comporte de diferentes formas:  </li> <li>El FROM hace referencia a la imagen desde la que comienza, en este caso un ubuntu 24.04. <pre><code>FROM ubuntu:24.04\n</code></pre></li> <li>Las LABEL introducen metadatos para trazabilidad y seguimiento del proyecto. <pre><code>LABEL AUTHOR=\"Fabi\u00e1n Alcaide\"\nLABEL DESCRIPTION=\"Imagen de web 2028\"\n</code></pre></li> <li>El RUN es de lo m\u00e1s importante del Dockerfile, pues contiene los comandos que se ejecutar\u00e1n al inicio del contenedor, en este caso:<ul> <li>Instalaci\u00f3n de nginx.</li> <li>Instalaci\u00f3n de git.</li> <li>Borrado de dependencias.</li> <li>Clonado de repositorio necesario.</li> <li>Copia de archivos a directorio virtual. <pre><code>RUN apt update &amp;&amp; \\\n    apt install nginx -y &amp;&amp; \\\n    apt install git -y &amp;&amp; \\\n    rm -rf /var/lib/apt/lists/*\n\nRUN git clone https://github.com/josejuansanchez/2048 /app &amp;&amp; \\\n    mv /app/* /var/www/html\n</code></pre></li> </ul> </li> <li>EXPOSE abre los puertos designados (recordemos que hay que abrir los puertos en la m\u00e1quina anfitri\u00f3n). <pre><code>EXPOSE 80\n</code></pre></li> <li>CMD permite ejecutar comandos como si fuese la consola. <pre><code>CMD [ \"nginx\", \"-g\", \"daemon off;\" ]\n</code></pre></li> <li>Una vez tenemos el Dockerfile listo, usamos el comando: <pre><code>docker build -t falclop/2048-fabian:1.0 .\n</code></pre> Este comando permite poner nombre (tag), versi\u00f3n y localizaci\u00f3n del dockerfile. Le ponemos nuestro nombre a la imagen para poder subirlo como imagen en DockerHub como no oficial.</li> </ol> <p>Una vez lanzamos el script, vemos nuestra imagen con Docker images </p> <p> </p> <ol> <li>Una vez tenemos las imagen, preparamos el docker-compose.yml <pre><code>services:\n  2048-fabian:\n    image: falclop/2048-fabian:1.0\n    ports: \n      - 8081:80\n</code></pre> Lo lanzamos con: <pre><code>docker compose up -d\n</code></pre></li> </ol> <p> </p> <p>Y como hemos hecho un port-forwarding al 8081:80 entramos a la ip o al nombre del dominio y veremos la aplicaci\u00f3n.  </p> <p> </p> <ol> <li>Cuando tenemos listo la imagen, la instalaci\u00f3n es correcta y funciona todo, podemos subir la imagen a nuestra cuenta de DockerHub, para ello primero haremos: <pre><code>docker login\n</code></pre></li> </ol> <p> </p> <p>Con esto podemos loguearnos en dockerhub para subirlo y poder hacer un push.</p> <pre><code>docker push falclop/2048-fabian:1\n</code></pre> <p>Con esto subimos la imagen a dockerhub </p> <p> </p> <p> </p> <ol> <li>Finalmente, vamos a crear un disparador en GitHub Actions para poder crear una automatizaci\u00f3n de CI/CD (Integraci\u00f3n y Despliegue continuo). Para ello dentro de nuestro repositorio entramos en Actions y el bot\u00f3n New Workflow.  </li> </ol> <p></p> <p>Nos crear\u00e1 una carpeta oculta en el que meter los diferentes disparadores, el nuestro ser\u00e1 el siguiente: <pre><code>name: Publish image to Docker Hub\n\n# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\non:\n  push:\n    branches: [ \"main\" ]\n    # Publish semver tags as releases.\n    tags: [ 'v*.*.*' ]\n  workflow_dispatch:\n\nenv:\n  # Use docker.io for Docker Hub if empty\n  REGISTRY: docker.io\n  # github.repository as &lt;account&gt;/&lt;repo&gt;\n  #IMAGE_NAME: ${{ github.repository }}\n  IMAGE_NAME: 2048-fabian\n  IMAGE_TAG: latest\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      # Set up BuildKit Docker container builder to be able to build\n      # multi-platform images and export cache\n      # https://github.com/docker/setup-buildx-action\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@f95db51fddba0c2d1ec667646a06c2ce06100226 # v3.0.0\n\n      # Login against a Docker registry except on PR\n      # https://github.com/docker/login-action\n      - name: Log into registry ${{ env.REGISTRY }}\n        uses: docker/login-action@343f7c4344506bcbf9b4de18042ae17996df046d # v3.0.0\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ secrets.DOCKERHUB_USER }}\n          password: ${{ secrets.DOCKERHUB_TOKEN }}\n\n      # This action can be used to check the content of the variables\n      - name: Debug\n        run: |\n          echo \"github.repository: ${{ github.repository }}\"\n          echo \"env.REGISTRY: ${{ env.REGISTRY }}\"\n          echo \"github.sha: ${{ github.sha }}\"\n          echo \"env.IMAGE_NAME: ${{ env.IMAGE_NAME }}\"\n\n      # Build and push Docker image with Buildx (don't push on PR)\n      # https://github.com/docker/build-push-action\n      - name: Build and push Docker image\n        id: build-and-push\n        uses: docker/build-push-action@0565240e2d4ab88bba5387d719585280857ece09 # v5.0.0\n        with:\n          context: .\n          push: ${{ github.event_name != 'pull_request' }}\n          tags: ${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}\n          cache-from: type=gha\n          cache-to: type=gha,mode=max     \n</code></pre> Lo que har\u00e1 ser\u00e1 subir la imagen a DockerHub cuando nosotros hagamos un push del repositorio.</p> <p>Primero se hace el push.  </p> <p> </p> <p>Y a continuaci\u00f3n salta el trigger y se sube a DockerHub</p> <p></p>"},{"location":"p8/","title":"Practica8.1-Hosting_compartido_PLESK","text":"<p>Creaci\u00f3n de un servidor Plesk para Hosting Compartido</p>"},{"location":"p8/#explicacion-de-la-practica","title":"Explicaci\u00f3n de la pr\u00e1ctica","text":"<p>Para esta pr\u00e1ctica vamos a implementar en una instancia de Ubuntu 24.04 Server un servidor Plesk. </p> <p>Plesk es una plataforma software de hosting que permite alojar y administrar sus aplicaciones web en un servidor virtual privado (VPS), en un servidor dedicado o en un servidor de un proveedor de servicios cloud.  </p> <p> </p> <p>Estos servidores permiten una gran versatilidad a la hora de ofrecer hosting compartido o servicios multimedia para los usuarios, por lo que se colocan como una soluci\u00f3n muy buena tanto a nivel profesional como usuario.  </p>"},{"location":"p8/#creacion-del-entorno","title":"Creaci\u00f3n del entorno","text":"<p>Lo primero de todo ser\u00e1 crear una instancia en AWS con Ubuntu 24.04 Server con las siguientes caracter\u00edsticas: - Nombre de la instancia: plesk. - Imagen (AMI): \u00daltima versi\u00f3n disponible de Ubuntu Server. - Arquitectura: x86. - Tipo de instancia: t2.medium (2 vCPUs, 4 GB de RAM). - Par de claves: vockey. - Grupo de seguridad: Crear un grupo de seguridad para plesk. - Almacenamiento: 30 GB de disco EBS. - Ip el\u00e1stica.  </p> <p></p> <p>Despu\u00e9s debemos crear un grupo de seguridad que llamaremos sg_plesk con las siguientes reglas de seguridad: - 22: SSH (TCP) - 80: HTTP (TCP) - 443: HTTPS (TCP) - 21: FTP (TCP) - Puerto de control en los modos activo y pasivo - 20: FTP (TCP) - Puerto de datos en el modo activo - 49152 - 65535: Rango de puertos din\u00e1micos para el modo pasivo (TCP) - 25: SMTP (TCP) - 465: SMTPS (TCP) - 143: IMAP (TCP) - 993: IMAPS (TCP) - 110: POP3 (TCP) - 995: POP3S (TCP)</p> <p> </p>"},{"location":"p8/#despliegue-del-servidor","title":"Despliegue del servidor","text":"<p>Una vez entendido como funciona el servicio de hosting compartido de Plesk, lanzaremos el sistema, primero debemos lanzar como sudo, nuestro archivo install_plesk.sh</p> <pre><code># Descargamos las dependecias de plesk\nwget https://autoinstall.plesk.com/plesk-installer\n\n# Le damos permisos de ejecuci\u00f3n \nchmod +x plesk-installer\n\n# Ejecutamos el \n./plesk-installer install plesk\n</code></pre> <p>Y esperaremos aproximadamente 10 minutos y nos dar\u00e1 un enlace para poder entrar en nuestro servicio para colocar la primera contrase\u00f1a de administrador.  </p> <p></p> <p>Adem\u00e1s si colocamos el comando: <pre><code>login plesk\n</code></pre> Podremos ver ese enlace otra vez.  </p> <p>Una vez estemos dentro veremos un dashboard con diferentes opciones. Ahora vamos a trabajar con \u00e9l.</p> <p></p>"},{"location":"p8/#administracion-de-sitios","title":"Administraci\u00f3n de sitios","text":"<p>Para esta pr\u00e1ctica vamos a crear diferentes sitios dentro de nuestro Plesk.  </p>"},{"location":"p8/#sitio-estatico","title":"Sitio est\u00e1tico","text":"<p>Le damos a Add Domain y veremos una pantalla para crear una p\u00e1gina, esta podr\u00e1 ser en blanco, una aplicaci\u00f3n, a partir de un repositorio, etc... Nosotros ahora vamos a crear un sitio est\u00e1tico y le damos a Blank website.  </p> <p></p> <p>Y colocamos el dominio, que en nuestro caso vamos a utilizar el sitio de redireccionamiento de dominio nip.io</p> <p> </p> <p>Y una vez creado veremos un dashboard propio de nuestra web.  </p> <p> </p> <p>Como nosotros vamos a establecer un sitio virtual que creamos en otra asignatura, vamos a instalarlo yendo al apartado file del nuestro sitio.</p> <p></p> <p>Y una vez tenemos el directorio instalado, entramos en la direcci\u00f3n.  </p> <p> </p>"},{"location":"p8/#sitio-wordpress","title":"Sitio Wordpress","text":"<p>Luego vamos a crear un sitio nuevo de wordpress. Para ello creamos un nuevo sitio como anteriormente, pero se\u00f1alamos la instalaci\u00f3n de WordPress.  </p> <p> </p> <p>Colocamos la ip y el nombre de dominio.  </p> <p> </p> <p>Y veremos en el mismo sitio, el dashboard de nuestro Wordpress.</p> <p> </p> <p>Y al acceder a nuestro sitio veremos nuestro wordpress.  </p> <p></p> <p>Luego vamos a ver como nuestro sitio no est\u00e1 securizado.</p> <p></p> <p>Entramos en el apartado, elegimos certificado Let's Encrypt, que se encargar\u00e1 de hacer los desaf\u00edos necesarios para obtener el certificado.</p> <p></p> <p>Y finalmente daremos en el apartado de securizaci\u00f3n e instalaremos todas las actualizaciones necesarias para tener al d\u00eda nuestro sitio y evitar ataques malintencionados.</p> <p></p> <p></p>"}]}